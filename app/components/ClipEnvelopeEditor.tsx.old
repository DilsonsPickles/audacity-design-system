'use client';

import { useEffect, useRef, useState } from 'react';

// Types
interface EnvelopePoint {
  time: number;
  db: number;
}

interface Clip {
  id: number;
  startTime: number;
  duration: number;
  waveform: number[];
  envelopePoints: EnvelopePoint[];
}

interface Track {
  id: number;
  name: string;
  clips: Clip[];
}

interface DragState {
  clip: Clip;
  trackIndex: number;
  offsetX: number;
  initialX: number;
  initialTrackIndex: number;
}

interface EnvelopeDragState {
  clip: Clip;
  pointIndex: number;
  trackIndex: number;
  clipX: number;
  clipWidth: number;
  clipY: number;
  clipHeight: number;
  startX: number;
  startY: number;
  deletedPoints: EnvelopePoint[]; // Track points that were deleted during drag
  originalTime: number; // Original time position of the dragged point
}

// Configuration
const TRACK_HEIGHT = 150;
const RULER_WIDTH = 50;
const PIXELS_PER_SECOND = 100;
const CANVAS_WIDTH = 2000;

export default function ClipEnvelopeEditor() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [envelopeMode, setEnvelopeMode] = useState(false);
  const [tracks, setTracks] = useState<Track[]>([]);
  const dragStateRef = useRef<DragState | null>(null);
  const envelopeDragStateRef = useRef<EnvelopeDragState | null>(null);

  // Initialize tracks with sample clips
  useEffect(() => {
    let clipIdCounter = 1;

    const generateWaveform = (duration: number): number[] => {
      const sampleCount = Math.floor(duration * 100);
      const waveform: number[] = [];

      for (let i = 0; i < sampleCount; i++) {
        const t = i / sampleCount;
        const value =
          Math.sin(t * Math.PI * 8) * 0.8 +
          Math.sin(t * Math.PI * 20) * 0.3 +
          Math.sin(t * Math.PI * 50) * 0.15 +
          (Math.random() - 0.5) * 0.1;
        waveform.push(Math.max(-1, Math.min(1, value)));
      }

      return waveform;
    };

    const createClip = (id: number, startTime: number, duration: number): Clip => ({
      id,
      startTime,
      duration,
      waveform: generateWaveform(duration),
      envelopePoints: [],
    });

    const initialTracks: Track[] = [
      {
        id: 1,
        name: 'Track 1',
        clips: [
          createClip(clipIdCounter++, 0.5, 2.0),
          createClip(clipIdCounter++, 3.0, 1.5),
        ],
      },
      {
        id: 2,
        name: 'Track 2',
        clips: [
          createClip(clipIdCounter++, 0.2, 1.2),
          createClip(clipIdCounter++, 2.0, 2.5),
          createClip(clipIdCounter++, 5.0, 1.0),
        ],
      },
      {
        id: 3,
        name: 'Track 3',
        clips: [
          createClip(clipIdCounter++, 1.0, 3.0),
          createClip(clipIdCounter++, 5.5, 1.5),
        ],
      },
    ];

    setTracks(initialTracks);
  }, []);

  // Setup canvas and render
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || tracks.length === 0) return;

    canvas.width = CANVAS_WIDTH;
    canvas.height = tracks.length * TRACK_HEIGHT;

    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';
    canvas.width *= dpr;
    canvas.height *= dpr;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.scale(dpr, dpr);

    render(ctx, tracks, envelopeMode);
  }, [tracks, envelopeMode]);

  const render = (ctx: CanvasRenderingContext2D, tracks: Track[], envelopeMode: boolean) => {
    const dpr = window.devicePixelRatio || 1;
    const canvas = ctx.canvas;

    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

    tracks.forEach((track, trackIndex) => {
      const y = trackIndex * TRACK_HEIGHT;

      // Draw track background
      ctx.fillStyle = trackIndex % 2 === 0 ? '#1e1e1e' : '#222222';
      ctx.fillRect(0, y, CANVAS_WIDTH, TRACK_HEIGHT);

      // Draw track separator
      ctx.strokeStyle = '#2a2a2a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(CANVAS_WIDTH, y);
      ctx.stroke();

      // Draw clips
      track.clips.forEach((clip) => {
        drawClip(ctx, clip, trackIndex, envelopeMode);
      });
    });
  };

  const drawClip = (ctx: CanvasRenderingContext2D, clip: Clip, trackIndex: number, envelopeMode: boolean) => {
    const x = clip.startTime * PIXELS_PER_SECOND;
    const y = trackIndex * TRACK_HEIGHT;
    const width = clip.duration * PIXELS_PER_SECOND;
    const height = TRACK_HEIGHT;

    // Clip background
    ctx.fillStyle = envelopeMode ? '#3a4a5a' : '#3a5a7a';
    ctx.fillRect(x, y, width, height);

    // Clip border
    ctx.strokeStyle = envelopeMode ? '#6a6a8a' : '#5a8aba';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, width, height);

    // Draw waveform
    drawWaveform(ctx, clip.waveform, x, y, width, height);

    // Draw envelope in envelope mode
    if (envelopeMode) {
      drawEnvelope(ctx, clip, x, y, width, height);
    }
  };

  const drawWaveform = (
    ctx: CanvasRenderingContext2D,
    waveform: number[],
    x: number,
    y: number,
    width: number,
    height: number
  ) => {
    if (waveform.length === 0) return;

    const centerY = y + height / 2;
    const maxAmplitude = height / 2 - 10;

    ctx.strokeStyle = '#8ac6ff';
    ctx.lineWidth = 1;
    ctx.beginPath();

    for (let i = 0; i < waveform.length; i++) {
      const px = x + (i / waveform.length) * width;
      const py = centerY + waveform[i] * maxAmplitude;

      if (i === 0) {
        ctx.moveTo(px, py);
      } else {
        ctx.lineTo(px, py);
      }
    }

    ctx.stroke();

    // Draw center line
    ctx.strokeStyle = '#4a4a4a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, centerY);
    ctx.lineTo(x + width, centerY);
    ctx.stroke();
  };

  const drawEnvelope = (
    ctx: CanvasRenderingContext2D,
    clip: Clip,
    x: number,
    y: number,
    width: number,
    height: number
  ) => {
    const dbToY = (db: number) => {
      const minDb = -60;
      const maxDb = 12;
      const normalized = (db - minDb) / (maxDb - minDb);
      return y + height - normalized * height;
    };

    const zeroDB_Y = dbToY(0);

    // Draw 0dB reference line
    ctx.strokeStyle = '#ffaa00';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(x, zeroDB_Y);
    ctx.lineTo(x + width, zeroDB_Y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw envelope line
    if (clip.envelopePoints.length > 0) {
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 2;
      ctx.beginPath();

      const startY =
        clip.envelopePoints.length > 0 && clip.envelopePoints[0].time === 0
          ? dbToY(clip.envelopePoints[0].db)
          : zeroDB_Y;
      ctx.moveTo(x, startY);

      clip.envelopePoints.forEach((point) => {
        const px = x + (point.time / clip.duration) * width;
        const py = dbToY(point.db);
        ctx.lineTo(px, py);
      });

      const lastPoint = clip.envelopePoints[clip.envelopePoints.length - 1];
      if (lastPoint.time < clip.duration) {
        ctx.lineTo(x + width, dbToY(lastPoint.db));
      }

      ctx.stroke();

      // Draw control points
      clip.envelopePoints.forEach((point) => {
        const px = x + (point.time / clip.duration) * width;
        const py = dbToY(point.db);

        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.arc(px, py, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }
  };

  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (envelopeMode) {
      if (handleEnvelopeClick(x, y)) {
        return;
      }
    }

    if (!envelopeMode) {
      for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
        const track = tracks[trackIndex];
        const trackY = trackIndex * TRACK_HEIGHT;

        if (y < trackY || y > trackY + TRACK_HEIGHT) continue;

        for (const clip of track.clips) {
          const clipX = clip.startTime * PIXELS_PER_SECOND;
          const clipWidth = clip.duration * PIXELS_PER_SECOND;

          if (x >= clipX && x <= clipX + clipWidth) {
            dragStateRef.current = {
              clip,
              trackIndex,
              offsetX: x - clipX,
              initialX: x,
              initialTrackIndex: trackIndex,
            };
            canvas.style.cursor = 'grabbing';
            return;
          }
        }
      }
    }
  };

  const handleEnvelopeClick = (x: number, y: number): boolean => {
    const CLICK_THRESHOLD = 8;

    const dbToY = (db: number, trackY: number, height: number) => {
      const minDb = -60;
      const maxDb = 12;
      const normalized = (db - minDb) / (maxDb - minDb);
      return trackY + height - normalized * height;
    };

    const yToDb = (y: number, trackY: number, height: number) => {
      const minDb = -60;
      const maxDb = 12;
      const normalized = (trackY + height - y) / height;
      return minDb + normalized * (maxDb - minDb);
    };

    for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
      const track = tracks[trackIndex];
      const trackY = trackIndex * TRACK_HEIGHT;

      if (y < trackY || y > trackY + TRACK_HEIGHT) continue;

      for (const clip of track.clips) {
        const clipX = clip.startTime * PIXELS_PER_SECOND;
        const clipWidth = clip.duration * PIXELS_PER_SECOND;
        const clipY = trackY;
        const clipHeight = TRACK_HEIGHT;

        if (x >= clipX && x <= clipX + clipWidth) {
          // Check for existing point
          for (let i = 0; i < clip.envelopePoints.length; i++) {
            const point = clip.envelopePoints[i];
            const px = clipX + (point.time / clip.duration) * clipWidth;
            const py = dbToY(point.db, clipY, clipHeight);

            const distance = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
            if (distance <= CLICK_THRESHOLD) {
              envelopeDragStateRef.current = {
                clip,
                pointIndex: i,
                trackIndex,
                clipX,
                clipWidth,
                clipY,
                clipHeight,
                startX: x,
                startY: y,
                deletedPoints: [],
                originalTime: point.time,
              };
              return true;
            }
          }

          // Create new point
          const relativeTime = ((x - clipX) / clipWidth) * clip.duration;
          const db = yToDb(y, clipY, clipHeight);

          const newTracks = [...tracks];
          newTracks[trackIndex].clips = newTracks[trackIndex].clips.map((c) =>
            c.id === clip.id
              ? {
                  ...c,
                  envelopePoints: [...c.envelopePoints, { time: relativeTime, db }].sort(
                    (a, b) => a.time - b.time
                  ),
                }
              : c
          );

          setTracks(newTracks);
          return true;
        }
      }
    }

    return false;
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Handle envelope point dragging
    if (envelopeDragStateRef.current) {
      const { clip, pointIndex, clipX, clipWidth, clipY, clipHeight, trackIndex } =
        envelopeDragStateRef.current;

      const yToDb = (y: number, trackY: number, height: number) => {
        const minDb = -60;
        const maxDb = 12;
        const normalized = (trackY + height - y) / height;
        return Math.max(minDb, Math.min(maxDb, minDb + normalized * (maxDb - minDb)));
      };

      const relativeTime = Math.max(0, Math.min(clip.duration, ((x - clipX) / clipWidth) * clip.duration));
      const db = yToDb(y, clipY, clipHeight);

      const newTracks = [...tracks];
      const targetClip = newTracks[trackIndex].clips.find((c) => c.id === clip.id);
      if (targetClip && envelopeDragStateRef.current) {
        const { originalTime, deletedPoints } = envelopeDragStateRef.current;

        // Check which deleted points should be restored
        const pointsToRestore: EnvelopePoint[] = [];
        const stillDeletedPoints: EnvelopePoint[] = [];

        deletedPoints.forEach((deletedPoint) => {
          // A point should be restored if it's no longer between originalTime and relativeTime
          const minTime = Math.min(originalTime, relativeTime);
          const maxTime = Math.max(originalTime, relativeTime);

          const isBetween = deletedPoint.time > minTime && deletedPoint.time < maxTime;

          if (!isBetween) {
            // No longer crossed, restore it
            pointsToRestore.push(deletedPoint);
          } else {
            // Still crossed, keep it deleted
            stillDeletedPoints.push(deletedPoint);
          }
        });

        // Restore points that are no longer crossed
        pointsToRestore.forEach((point) => {
          targetClip.envelopePoints.push(point);
        });

        // Update the point position
        targetClip.envelopePoints[pointIndex] = { time: relativeTime, db };

        // Check if we're crossing any new points
        const pointsToDelete: { index: number; point: EnvelopePoint }[] = [];

        for (let i = 0; i < targetClip.envelopePoints.length; i++) {
          if (i === pointIndex) continue;

          const otherPoint = targetClip.envelopePoints[i];

          // If we moved right and crossed a point on the right, delete it
          if (relativeTime > originalTime && otherPoint.time > originalTime && otherPoint.time <= relativeTime) {
            // Only delete if not already in deletedPoints
            if (!stillDeletedPoints.some(p => p.time === otherPoint.time && p.db === otherPoint.db)) {
              pointsToDelete.push({ index: i, point: otherPoint });
            }
          }
          // If we moved left and crossed a point on the left, delete it
          else if (relativeTime < originalTime && otherPoint.time < originalTime && otherPoint.time >= relativeTime) {
            // Only delete if not already in deletedPoints
            if (!stillDeletedPoints.some(p => p.time === otherPoint.time && p.db === otherPoint.db)) {
              pointsToDelete.push({ index: i, point: otherPoint });
            }
          }
        }

        // Delete newly crossed points (in reverse order to maintain indices)
        pointsToDelete.sort((a, b) => b.index - a.index).forEach(({ index, point }) => {
          targetClip.envelopePoints.splice(index, 1);
          stillDeletedPoints.push(point);
          // Adjust pointIndex if we deleted points before it
          if (index < pointIndex) {
            envelopeDragStateRef.current!.pointIndex--;
          }
        });

        // Update the deleted points list
        envelopeDragStateRef.current.deletedPoints = stillDeletedPoints;

        targetClip.envelopePoints.sort((a, b) => a.time - b.time);
        setTracks(newTracks);
      }

      return;
    }

    if (!dragStateRef.current) {
      updateCursor(x, y);
      return;
    }

    // Update clip position
    const newStartTime = Math.max(0, (x - dragStateRef.current.offsetX) / PIXELS_PER_SECOND);
    const newTrackIndex = Math.floor(y / TRACK_HEIGHT);

    const newTracks = [...tracks];
    const { clip, trackIndex } = dragStateRef.current;

    if (
      newTrackIndex >= 0 &&
      newTrackIndex < tracks.length &&
      newTrackIndex !== trackIndex
    ) {
      // Move to different track
      newTracks[trackIndex].clips = newTracks[trackIndex].clips.filter((c) => c.id !== clip.id);
      newTracks[newTrackIndex].clips.push({ ...clip, startTime: newStartTime });
      dragStateRef.current.trackIndex = newTrackIndex;
    } else {
      // Update in same track
      newTracks[trackIndex].clips = newTracks[trackIndex].clips.map((c) =>
        c.id === clip.id ? { ...c, startTime: newStartTime } : c
      );
    }

    setTracks(newTracks);
  };

  const handleMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    if (envelopeDragStateRef.current) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const distance = Math.sqrt(
        (x - envelopeDragStateRef.current.startX) ** 2 +
          (y - envelopeDragStateRef.current.startY) ** 2
      );

      // If no movement, delete the point
      if (distance < 3) {
        const { clip, pointIndex, trackIndex } = envelopeDragStateRef.current;
        const newTracks = [...tracks];
        const targetClip = newTracks[trackIndex].clips.find((c) => c.id === clip.id);
        if (targetClip) {
          targetClip.envelopePoints.splice(pointIndex, 1);
          setTracks(newTracks);
        }
      }

      envelopeDragStateRef.current = null;
      return;
    }

    if (dragStateRef.current) {
      dragStateRef.current = null;
      canvas.style.cursor = 'default';
    }
  };

  const updateCursor = (x: number, y: number) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    let overClip = false;

    for (let trackIndex = 0; trackIndex < tracks.length; trackIndex++) {
      const track = tracks[trackIndex];
      const trackY = trackIndex * TRACK_HEIGHT;

      if (y < trackY || y > trackY + TRACK_HEIGHT) continue;

      for (const clip of track.clips) {
        const clipX = clip.startTime * PIXELS_PER_SECOND;
        const clipWidth = clip.duration * PIXELS_PER_SECOND;

        if (x >= clipX && x <= clipX + clipWidth) {
          overClip = true;
          break;
        }
      }
      if (overClip) break;
    }

    canvas.style.cursor = overClip ? 'grab' : 'default';
  };

  return (
    <div className="flex flex-col h-screen bg-[#1a1a1a]">
      {/* Toolbar */}
      <div className="h-[50px] bg-[#2a2a2a] border-b border-[#3a3a3a] flex items-center px-4 gap-2">
        <button
          onClick={() => setEnvelopeMode(!envelopeMode)}
          className={`flex items-center gap-2 px-4 py-2 rounded border transition-all ${
            envelopeMode
              ? 'bg-[#4a7a9a] border-[#5a8aba] text-white'
              : 'bg-[#3a3a3a] border-[#4a4a4a] text-[#ccc] hover:bg-[#4a4a4a] hover:border-[#5a5a5a]'
          }`}
        >
          <i className="fas fa-wave-square text-base"></i>
          <span className="text-sm">Clip Envelopes</span>
        </button>
      </div>

      {/* Main content area */}
      <div className="flex flex-1 overflow-hidden">
        {/* Track headers */}
        <div className="w-[200px] bg-[#2a2a2a] border-r border-[#3a3a3a] overflow-y-auto">
          {tracks.map((track) => (
            <div
              key={track.id}
              className="h-[150px] p-2 border-b border-[#3a3a3a] flex flex-col"
            >
              <h3 className="text-sm font-medium mb-2 text-white">{track.name}</h3>
              <div className="flex gap-2 mt-auto">
                <button className="px-2 py-1 text-xs bg-[#3a3a3a] border border-[#4a4a4a] text-[#ccc] rounded hover:bg-[#4a4a4a]">
                  M
                </button>
                <button className="px-2 py-1 text-xs bg-[#3a3a3a] border border-[#4a4a4a] text-[#ccc] rounded hover:bg-[#4a4a4a]">
                  S
                </button>
              </div>
            </div>
          ))}
        </div>

        {/* Canvas container */}
        <div className="flex-1 overflow-auto relative">
          <canvas
            ref={canvasRef}
            className="block bg-[#1e1e1e]"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          />
        </div>

        {/* Rulers (fixed on right) */}
        <div className="fixed right-0 top-[50px] w-[50px] h-[calc(100vh-50px)] bg-[#2a2a2a] pointer-events-none z-10">
          {tracks.map((track, index) => (
            <div
              key={track.id}
              className="h-[150px] border-b border-l border-[#3a3a3a] relative"
            >
              {[
                { label: '+1.0', pos: '0%' },
                { label: '+0.5', pos: '25%' },
                { label: '0.0', pos: '50%' },
                { label: '-0.5', pos: '75%' },
                { label: '-1.0', pos: '100%' },
              ].map(({ label, pos }) => (
                <div key={label}>
                  <div
                    className="absolute left-[5px] w-[10px] h-[1px] bg-[#555]"
                    style={{ top: pos }}
                  />
                  <div
                    className="absolute right-[5px] text-[10px] font-mono text-[#aaa]"
                    style={{ top: `calc(${pos} - 5px)` }}
                  >
                    {label}
                  </div>
                </div>
              ))}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
